# Spiking 

Run both vulnserver and ImmunityDebugger
Connect to Windows machine from Linux using netcat:
```
nc -nv <WindowsIP> 9999
```

9999 is the vulnserver port

Immediately connect to VulnServer!
```text
Welcome to Vulnerable Server! Enter HELP for help.
HELP
Valid Commands:
HELP
STATS [stat_value]
RTIME [rtime_value]
LTIME [ltime_value]
SRUN [srun_value]
TRUN [trun_value]
GMON [gmon_value]
GDOG [gdog_value]
KSTET [kstet_value]
GTER [gter_value]
HTER [hter_value]
LTER [lter_value]
KSTAN [lstan_value]
EXIT
```

We will focus on the `TRUN` command which in itself is vulnerable. How to find that?:

Use **spiking** and test every command for Buffer Overflow
To spike, will use `generic_send_tcp`
First, EXIT the VulnServer

```shell
root@kali:~# generic_send_tcp 
argc=1
Usage: ./generic_send_tcp host port spike_script SKIPVAR SKIPSTR
./generic_send_tcp 192.168.1.100 701 something.spk 0 0
```

We will leave te variables SKIPVAR and SKIPSTR as 0 
but we need a spike_script

We will provide the script for `stats.spk`:
```shell
s_readline();
s_string("STATS ");
s_string_variable("0");
```
when we spike this, it will send variables in all forms and iterations, e.g. 1000 at a time or 5 at a time or 20000 at a time randomly to try and break it 

Also make a `trunk.spk`
```shell
s_readline();
s_string("TRUN ");
s_string_variable("0");
```

Run them:
```
generic_send_tcp 10.0.2.15 9999 stats.spk 0 0
generic_send_tcp 10.0.2.15 9999 trun.spk 0 0
```

First one, nothing really happens, second one, debugger pauses and we can check the registers:
![](https://github.com/Cyberd0xed/practical-ethical-hacking/blob/main/resources/0a59b0d43a474ebab6e35c7d3671712a.png?raw=true)

We can see that the EAX register has overflowed 
On EBP we see 41414141 which is hex code for four A's

